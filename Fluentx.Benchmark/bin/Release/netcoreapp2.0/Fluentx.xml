<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fluentx</name>
    </assembly>
    <members>
        <member name="T:Fluentx.Age">
            <summary>
            A class representing a simple age entity.
            </summary>
        </member>
        <member name="P:Fluentx.Age.Years">
            <summary>
            Years
            </summary>
        </member>
        <member name="P:Fluentx.Age.Months">
            <summary>
            Months
            </summary>
        </member>
        <member name="P:Fluentx.Age.Days">
            <summary>
            Days
            </summary>
        </member>
        <member name="P:Fluentx.Age.Hours">
            <summary>
            Hours
            </summary>
        </member>
        <member name="P:Fluentx.Age.Minutes">
            <summary>
            Minutes
            </summary>
        </member>
        <member name="P:Fluentx.Age.Seconds">
            <summary>
            Seconds
            </summary>
        </member>
        <member name="M:Fluentx.Age.ToString">
            <summary>
            Returns a human ready read text for the age entity.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Age.ToYMDString">
            <summary>
            Returns a human ready read text for the age entity with only years, months and days.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Expresser`1">
            <summary>
            Experimental class: Expresser expresses an entity's properties in a strongly typed format using lambda expressions, instead of 
            creating too many POCO's you can use the expresser to transfer the entity's data that you want.
            </summary>
            <typeparam name="TEntity"></typeparam>    
        </member>
        <member name="M:Fluentx.Expresser`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Set(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="memberPath"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.TrySet``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Set(`0,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Expressers all direct public properties and fields within the entity EXCEPT what has has been specified.
            </summary>
            <param name="entity"></param>
            <param name="excepters"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Get``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.TryGet``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.RecursiveExpressionPath(System.String,System.Linq.Expressions.MemberExpression)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.Create(`0,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="excepters"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Extensions">
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
        </member>
        <member name="M:Fluentx.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Extension method to perform For Each operation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            (Synonym to ForEach) Extension method to perform For Each operation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            (Synonym to ForEach) Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.NotContains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns whether the specified source doesn't contain the specified value or not.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns whether the specified source doesn't contain the specified value or not.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <param name="value"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Random``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Extension method to perform random return of an item within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.RandomRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a random sequential range from the specified Enumeration.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNull``1(``0)">
            <summary>
            Extension method to evaluate if object is null.
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNotNull``1(``0)">
            <summary>
            Extension method to evaluate if object is not null
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.In``1(``0,``0[])">
            <summary>
            Extension method to evaluate if the specified object exists within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NotIn``1(``0,``0[])">
            <summary>
            Extension method to evaluate if the specified object doest not exists within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Extension method that returns whether the specified Enumerable is null or empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IfTrue(System.Boolean,System.Action)">
            <summary>
            Extension method that performs the action if the value is true.
            </summary>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.IfTrue``1(System.Boolean,System.Func{``0})">
            <summary>
            Returns the specified expression value when the value is true.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenTrue``1(System.Boolean,``0)">
            <summary>
            Returns the specified expression value when the value is true.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenFalse``1(System.Boolean,System.Func{``0})">
            <summary>
            Returns the specified expression value when the value is false.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenFalse``1(System.Boolean,``0)">
            <summary>
            Returns the specified expression value when the value is false.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IfFalse(System.Boolean,System.Action)">
            <summary>
            Extension method that performs the action if the value is false. Returns the same boolean value.
            </summary>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Is``1(``0)">
            <summary>
            Extension method that performs a boolean evaluation if @this is of type T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.As``1(``0)">
            <summary>
            Extension method that performs a safe cast for @this as T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Lock``1(``0,System.Action{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action with @this as the parameter for the action.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Between``1(``0,``0,``0)">
            <summary>
            Returns if a @this in between the specified range without including the edges.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="lower"></param>
            <param name="upper"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BetweenIncludeEdges``1(``0,``0,``0)">
            <summary>
            Returns if a @this in between the specified range including the edges.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="lower"></param>
            <param name="upper"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BetweenRegardless``1(``0,``0,``0)">
            <summary>
            Returns if a @this in between the specified range regardless of the order without including the edges.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="endpoint1"></param>
            <param name="endpoint2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BetweenRegardlessIncludeEdges``1(``0,``0,``0)">
            <summary>
            Returns if a @this in between the specified range regardless of the order including the edges.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="endpoint1"></param>
            <param name="endpoint2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ParseEnum``1(System.String,System.Boolean)">
            <summary>
            Parses a string to enum and throughs exceptions as if it fails.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ignorecase"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.TryParseEnum``1(System.String,System.Boolean)">
            <summary>
            Tries to Parse a string as an enum, if failed it returns the default value of the provided Type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ignorecase"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToHex(System.Int32)">
            <summary>
            Converts an integer into a Hex string.
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ParseHex(System.String)">
            <summary>
            Parses a Hex string to integer
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Set``1(``0,System.Action{``0})">
            <summary>
            Simple update of instance memebers using lambda expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Safe``2(``0,System.Func{``0,``1})">
            <summary>
            Safely tries to evaluate the specified expression path
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToCSV``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a comma separated string of the specified enumerable
            </summary>
            <param name="list"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the min element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the min element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the max element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the max element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Shuffles the specified list items randomly.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.KB(System.Int32)">
            <summary>
            KB stands for Kilo Byte. The value mutliplied by 1024. e.g. 3.KB()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MB(System.Int32)">
            <summary>
            MB stands for Mega Byte. The value mutliplied by 1024 * 1024. e.g. 4.MB()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.GB(System.Int32)">
            <summary>
            GB stands for Giga Byte. The value mutliplied by 1024 * 1024 * 1024. e.g. 4.GB()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.TB(System.Int32)">
            <summary>
            TB stands for Tera Byte. The value mutliplied by 1024 * 1024 * 1024 * 1024. e.g. 4.TB()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.PB(System.Int32)">
            <summary>
            PB stands for Peta Byte. The value mutliplied by 1024 * 1024 * 1024 * 1024. e.g. 4.PB()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an empty Enumerable if the specified enumerable is null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToCelcius(System.Double)">
            <summary>
            Fahrenheit to Celcius
            </summary>
            <param name="fahrenheit"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFahrenheit(System.Double)">
            <summary>
            Celcius to Fahrenheit 
            </summary>
            <param name="celius"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToCelcius(System.Int32)">
            <summary>
            Fahrenheit to Celcius
            </summary>
            <param name="fahrenheit"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFahrenheit(System.Int32)">
            <summary>
            Celcius to Fahrenheit
            </summary>
            <param name="celius"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToLBS(System.Double)">
            <summary>
            KG to LBS
            </summary>
            <param name="kg"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToKG(System.Double)">
            <summary>
            LBS to KG
            </summary>
            <param name="lbs"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToLBS(System.Int32)">
            <summary>
            KG to LBS
            </summary>
            <param name="kg"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToKG(System.Int32)">
            <summary>
            LBS to KG
            </summary>
            <param name="lbs"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFeet(System.Int32)">
            <summary>
            Converts meters to feets.
            </summary>
            <param name="meter"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToMeter(System.Int32)">
            <summary>
            LBS to KG
            </summary>
            <param name="feet"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFeet(System.Double)">
            <summary>
            Meters to Feet
            </summary>
            <param name="meter"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToMeter(System.Double)">
            <summary>
            LBS to KG
            </summary>
            <param name="feet"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NullOr``2(``0,System.Func{``0,``1},``1)">
            <summary>
            Tries to return the value of the specifed expression without checking for nullability.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <param name="elseValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Converts all elements of the specified enumerable to a concatenated string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>
            Converts all elements of the specified enumerable to a concatenated string using the specifed exp.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="exp"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.FromUnixTime(System.Int64)">
            <summary>
            Parses a unit time to datetime.
            </summary>
            <param name="unixTime"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUnixTimeInSeconds(System.DateTime)">
            <summary>
            Converts to unitx time in seconds
            </summary>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUnixTimeInMilliSeconds(System.DateTime)">
            <summary>
            Converts to unix time in milli seconds.
            </summary>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.January(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in January of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.February(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in February of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.March(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in March of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.April(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in April of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.May(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in May of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.June(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in June of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.July(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in July of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.August(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in August of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.September(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in September of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.October(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in October of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.November(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in November of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.December(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in December of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Of(System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Create a date time instance in human readable format.
            </summary>
            <param name="this"></param>
            <param name="month"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DayInYear(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date of the specifed day in year. e.g 365.DayInYear(2014) => 31/12/2014
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.SecondsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of seconds
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinutesAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of minutes
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.HoursAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of hours
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DaysAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of days
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MonthsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of months
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.YearsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of years
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.SecondsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of seconds
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinutesFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of minutes
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.HoursFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of hours
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DaysFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of days
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MonthsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of months
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.YearsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of years
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LastYear(System.DateTime)">
            <summary>
            
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NextYear(System.DateTime)">
            <summary>
            
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LastMonth(System.DateTime)">
            <summary>
            
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NextMonth(System.DateTime)">
            <summary>
            
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsWithin(System.DateTime,Fluentx.Period,System.Boolean)">
            <summary>
            Returns a boolean value wether the date is within the specifed period. (default : edges are not calculated within)
            </summary>
            <param name="this"></param>
            <param name="period"></param>
            /// <param name="includeEdges"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNotWithin(System.DateTime,Fluentx.Period,System.Boolean)">
            <summary>
            returns a boolean value wether the date is NOT within the specifed period. (default : edges are not calculated within)
            </summary>
            <param name="this"></param>
            <param name="period"></param>
            <param name="includeEdges"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EndOfDay(System.DateTime)">
            <summary>
            Returns end of day 23:59:59;
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.StartOfDay(System.DateTime)">
            <summary>
            Returns start of day 00:00:00
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Tomorrow(System.DateTime)">
            <summary>
            Returns tomorrow of the specified day
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NextDay(System.DateTime)">
            <summary>
            Returns next day of the specified day
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Yesterday(System.DateTime)">
            <summary>
            Returns yesterday of the specified day
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.PreviousDay(System.DateTime)">
            <summary>
            Returns yesterday of the specified day
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.At(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new datetime instance with the specified Hour(24 based), Minute, Second and MiliSecond
            </summary>
            <param name="this"></param>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="millisecond"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.StartOfMonth(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns start of the month as datetime.
            </summary>
            <param name="month"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EndOfMonth(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns end of the month as datetime.
            </summary>
            <param name="month"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.StartOfMonth(System.DateTime)">
            <summary>
            Returns start of the month as datetime.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EndOfMonth(System.DateTime)">
            <summary>
            Returns end of the month as datetime.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LastDayOfMonth(System.DateTime)">
            <summary>
            Returns last day of the month for the specified datetime value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LastDayOfMonth(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns last day of the month. 
            </summary>
            <param name="month"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsLeapYear(System.DateTime)">
            <summary>
            Returns whether this date time is in a leap year.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsLeapYear(System.Int32)">
            <summary>
             Returns whether the specified year is a leap year.
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Age(System.DateTime)">
            <summary>
            Creates an age instance from the specified datetime instance.
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Not(System.Boolean)">
            <summary>
            Negates a condition
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.And(System.Boolean,System.Boolean)">
            <summary>
            Anding with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.And(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Anding with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.AndNot(System.Boolean,System.Boolean)">
            <summary>
            Anding Not with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.AndNot(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Anding Not with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Or(System.Boolean,System.Boolean)">
            <summary>
            Oring with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Or(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Oring with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.OrNot(System.Boolean,System.Boolean)">
            <summary>
            Oring Not with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.OrNot(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Oring Not with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Xor(System.Boolean,System.Boolean)">
            <summary>
            Xoring with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Xor(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Xoring with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Haversine(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between two points on earth in meters.
            </summary>
            <param name="lat1"></param>
            <param name="lng1"></param>
            <param name="lat2"></param>
            <param name="lng2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LevenshteinDistance(System.String,System.String)">
            <summary>
            Levenshtein Distance is a string metric for measuring the difference between two sequences, distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Fibonacci(System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Factorial(System.Int32)">
            <summary>
            Return factorial value of specified number
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.GreatestCommonDivisor(System.Int32,System.Int32)">
            <summary>
            Returns greatest common advisor of the specified first number using the second number.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsArmstrong(System.Double)">
            <summary>
            An Armstrong number is an integer such that the sum of the cubes of its digits is equal to the number itself.
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Reverse(System.Int32)">
            <summary>
            This method reverses any number backwards.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsPalindrome(System.Int32)">
            <summary>
            This returns whether a number is palindrome or not.
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsPerfect(System.Int32)">
            <summary>
            A perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsStrong(System.Int32)">
            <summary>
            A strong number is a number where the sum of factorial of its digits is equal the number it self.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.PrimeFactor(System.Int32)">
            <summary>
            Any of the prime numbers that can be multiplied to give the original specified number
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Hypotenuse(System.Double,System.Double)">
            <summary>
            Hypotenuse is the longest side of a right-angled triangle, the side opposite of the right angle.
            </summary>
            <param name="side1"></param>
            <param name="side2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToWords(System.Int32)">
            <summary>
            Returns the wording of a specific number in english.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsPrime(System.Int32)">
            <summary>
            Returns whether a number is prime or not.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.LinearSearch``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Linear search implementation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BinarySearchFx``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Do a binary search on the specified ASSUMED sorted list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BinarySearchFx``1(System.Collections.Generic.IList{``0},``0,System.Int32,System.Int32)">
            <summary>
            Do a binary search on the specified ASSUMED sorted list, if not sorted an exception will be thrown
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="valueToFind"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BoyerMooreSearch(System.String,System.String)">
            <summary>
            Boyer Moore Search implementation
            </summary>
            <param name="text"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.KnuthMorrisPrattSearch(System.String,System.String)">
            <summary>
            Knuth Morris Pratt Search implementation.
            </summary>
            <param name="text"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.BruteForce(System.String,System.Int32,System.Int32,System.Func{System.String,System.Boolean})">
            <summary>
            Brute force search algorithm.
            </summary>
            <param name="text"></param>
            <param name="startLength"></param>
            <param name="endLength"></param>
            <param name="testCallback"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.RabinKarpSearch(System.String,System.String)">
            <summary>
            A Search algorithm that uses hashing to find any one of a set of pattern strings in a text.
            </summary>
            <param name="text"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.AnagramSearch(System.String,System.String)">
            <summary>
            This algorithm searches for all the occurrences of pattern and its permutations (or anagrams) in the specified text.
            </summary>
            <param name="text"></param>
            <param name="valueToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Sorts the list in ascending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Insertions Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSortDescending``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Sorts the list in descending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.Extensions.InsertionSortDescending``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Insertion Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.QuickSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Quick Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.QuickSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Quick Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.QuickSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Quick Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.QuickSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Wuick Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.CocktailSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Cocktail Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.CocktailSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Cocktail Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.CocktailSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Cocktail Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.CocktailSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Cocktail Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.OddEvenSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Odd Even Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.OddEvenSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Odd Even Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.OddEvenSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Odd Even Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.OddEvenSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Odd Even Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.CombSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Comb Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.CombSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Comb Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.CombSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Comb Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.CombSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Comb Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.GnomeSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Gnome Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.GnomeSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Gnome Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.GnomeSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Gnome Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.GnomeSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Gnome Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.ShellSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Shell Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.ShellSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Shell Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.ShellSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Shell Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.ShellSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Shell Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.IntroSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Intro Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Intro Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.IntroSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Intro Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.IntroSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Intro Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.BogoSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            NOT RECOMMENDED SEARCH, i have it here for experimental purposes only, it returns the number of times shuffling occured to get the list sorted.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.BogoSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            NOT RECOMMENDED SEARCH, I have it here for experimental purposes only, it returns the number of times shuffling occured to get the list sorted.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.SelectionSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Selection Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.SelectionSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Selection Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.SelectionSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Selection Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.SelectionSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Selection Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.HeapSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Heap Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.HeapSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Heap Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.BubbleSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Bubble Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.BubbleSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Bubble Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.BubbleSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Bubble Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.BubbleSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Bubble Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in ascending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSortDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the list in descending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSortDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Sorts the list in ascending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in ascending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSortDescending``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Sorts the list in descending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.Extensions.MergeSortDescending``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the list in descending order using Merge Sort algorithm
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Fluentx.Extensions.IsSorted``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns whether the specified list is sorted in ascending order or not, it uses linear search to validate order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsSorted``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns whether the specified list is sorted in ascending order or not, it uses linear search to validate order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsSortedDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns whether the specified list is sorted in descending order or not, it uses linear search to validate order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsSortedDescending``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns whether the specified list is sorted in descending order or not, it uses linear search to validate order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Reverses the list backwords.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:Fluentx.Extensions.FormatWith(System.String,System.Object[])">
            <summary>
            Extension method that performs the operation string.Format 
            </summary>
            <param name="this"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.To``1(System.IConvertible)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt32(System.String,System.Int32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt32(System.String,System.UInt32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt(System.String,System.Int32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt(System.String,System.UInt32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToLong(System.String,System.Int64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToULong(System.String,System.UInt64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt16(System.String,System.Int16)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt16(System.String,System.UInt16)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt64(System.String,System.Int64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt64(System.String,System.UInt64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDouble(System.String,System.Double)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFloat(System.String,System.Single)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDecimal(System.String,System.Decimal)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToByte(System.String,System.Byte)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToSByte(System.String,System.SByte)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToBool(System.String,System.Boolean)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDateTime(System.String,System.DateTime)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToGuid(System.String,System.Guid)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IgnoreCaseEqual(System.String,System.String)">
            <summary>
            Extension method to compare two strings for equality ignoring character case. (Note: uses Equals(string, StringComparison.OrdinalIgnoreCase)).
            </summary>
            <param name="this"></param>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Wordify(System.String)">
            <summary>
            Returns a string that holds the words splitted by space.e.g. thisIsGood => this Is Good
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WordCount(System.String,Fluentx.Extensions.WordCountAlgorithm)">
            <summary>
            Counts the words within the specified strings, two algorithms can be used, Regex is the default one used: more accurate but slower. Loop method is much much faster but less accurate.
            </summary>
            <param name="this"></param>
            <param name="algorithm"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Reverse(System.String)">
            <summary>
            Reverses the specifed string
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ReplaceLast(System.String,System.String,System.String)">
            <summary>
            Returns a new string in which the last occurrence of a specified string
            in this instance are replaced with another specified string.  
            </summary>
            <param name="this"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.CountOccurences(System.String,System.String)">
            <summary>
            Counts the occurences of the specified string within a string
            </summary>
            <param name="this"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ReplaceFirst(System.String,System.String,System.String)">
            <summary>
            Returns a new string in which the last occurrence of a specified string
            in this instance are replaced with another specified string.  
            </summary>
            <param name="this"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.XORCipher(System.String,System.String)">
            <summary>
            Encrypts the specified text with the specified key, decryption can be done using the same method on the ciphered data with the same key.
            </summary>
            <param name="this"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.APHash(System.String)">
            <summary>
            AP is a hybrid rotative and additive hash function algorithm.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.SorensenDiceMatch(System.String,System.String)">
            <summary>
            Returns a value of how much similar the two strings are.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.CesarEncrypt(System.String,System.Int32)">
            <summary>
            Encrypts a string using the Cesar algorithm.
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.CesarDecrypt(System.String,System.Int32)">
            <summary>
            Decrypts a string using cesar algorithm.
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Extensions.WordCountAlgorithm">
            <summary>
            Enumeration to specify which algorithm to use when counting words for the WordCount extension method
            </summary>
        </member>
        <member name="F:Fluentx.Extensions.WordCountAlgorithm.Regex">
            <summary>
            Uses regular expressions to count words, its not fast for long strings but its accurate in terms of comparing to Microsoft Word, deviation is 0.02%.
            Note: this benchmark is taken from http://www.dotnetperls.com
            </summary>
        </member>
        <member name="F:Fluentx.Extensions.WordCountAlgorithm.Loop">
            <summary>
            Uses a simple loop to check characters and count words, this method is faster than regex, but less accurate.
            </summary>
        </member>
        <member name="T:Fluentx.Fx">
            <summary>
            Fx is the main class for Fluentx and its a shortened name for Fluentx, Fx also is equivelant for the mathematical representation of F(x) :)
            </summary>
        </member>
        <member name="F:Fluentx.Fx.EPOCH">
            <summary>
            Unix Time EPOCH
            </summary>
        </member>
        <member name="F:Fluentx.Fx.GoldenRatio">
            <summary>
            The Golden Ratio
            </summary>
        </member>
        <member name="F:Fluentx.Fx.PI">
            <summary>
            PI represented as 22/7.
            </summary>
        </member>
        <member name="P:Fluentx.Fx.Action">
            <summary>
            Used for a single default action
            </summary>
        </member>
        <member name="M:Fluentx.Fx.WhileTrue(System.Func{System.Boolean})">
            <summary>
            Performs a while control as long the action is evaluating to true.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileFalse(System.Func{System.Boolean})">
            <summary>
            Performs a while control as long the action is evaluating to false.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileTrueFor(System.Func{System.Boolean},System.UInt16)">
            <summary>
            Performs a while control as long the action is evaluating to true for a maximum of <paramref name="maxLoops"/>
            </summary>
            <param name="action"></param>
            <param name="maxLoops"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileFalseFor(System.Func{System.Boolean},System.UInt16)">
            <summary>
            Performs a while control as long the action is evaluating to false for a maximum of <paramref name="maxLoops"/>
            </summary>
            <param name="action"></param>
            <param name="maxLoops"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Func{System.Boolean},System.Action)">
            <summary>
            Performs a while control using the evaluation condition for the specified action.
            </summary>
            <param name="condition"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Boolean,System.Action)">
            <summary>
            Performs a while control using specified condition for the specified action.
            </summary>
            <param name="condition"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of a while statement using the specified condition, this requires the call to Do eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Do(System.Action)">
            <summary>
            Prepare for the excution of a Do-While statement using the specified condition, this requires the call to While eventually.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.If(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.If(System.Boolean)">
            <summary>
            Prepare for the excution of IF statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.When(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF statement (alternative for IF), requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.When(System.Boolean)">
            <summary>
            Prepare for the excution of IF statement (alternative for IF), requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.IfNot(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF NOT statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.IfNot(System.Boolean)">
            <summary>
            Prepare for the excution of IF NOT statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Prepares for the execution of a foreach statement, this requires the call to Do eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            (Synonym to ForEach) Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            (Synonym to ForEach) Prepares for the execution of a foreach statement, this requires the call to Do eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Try(System.Action)">
            <summary>
            Prepares for the excution of a Try/Catch action, this requires the call to one of the following actions eventually: Catch, Swallow, SwalloIf.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Using``1(``0,System.Action{``0})">
            <summary>
            Performs a using statement for disposable objects by executing action.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch``1(``0)">
            <summary>
            Prepares for a switch statement over the specified mainOperand, this requires the call to Default eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mainOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch(System.Type)">
            <summary>
            Prepares for a switch statement over the specified type, this requires the call to Default eventually.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch``1">
            <summary>
            Prepares for a switch statement over the specified type T, this requires the call to Default eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.RetryOnFail(System.Func{System.Boolean},System.UInt16,System.UInt16)">
            <summary>
            Performs an action, if the action failed (returned false) it re-attempts to do the action again for <paramref name="attempts"/>, and waits for <paramref name="attemptSleepInMilliSeconds"/> between each attempt.
            </summary>
            <param name="action"></param>
            <param name="attempts"></param>
            <param name="attemptSleepInMilliSeconds"></param>
        </member>
        <member name="M:Fluentx.Fx.ToInt32(System.String,System.Int32)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt32(System.String,System.UInt32)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt(System.String,System.Int32)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt(System.String,System.UInt32)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToLong(System.String,System.Int64)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToULong(System.String,System.UInt64)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt16(System.String,System.Int16)">
            <summary>
            Tries to parse specified string to Int16, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt16(System.String,System.UInt16)">
            <summary>
            Tries to parse specified string to UInt16, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt64(System.String,System.Int64)">
            <summary>
            Tries to parse specified string to Int64, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt64(System.String,System.UInt64)">
            <summary>
            Tries to parse specified string to UInt64, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDouble(System.String,System.Double)">
            <summary>
            Tries to parse specified string to double, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToFloat(System.String,System.Single)">
            <summary>
            Tries to parse specified string to float, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDecimal(System.String,System.Decimal)">
            <summary>
            Tries to parse specified string to decimal, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToByte(System.String,System.Byte)">
            <summary>
            Tries to parse specified string to byte, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToSByte(System.String,System.SByte)">
            <summary>
            Tries to parse specified string to sbyte, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToBool(System.String,System.Boolean)">
            <summary>
            Tries to parse specified string to bool, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDateTime(System.String,System.DateTime)">
            <summary>
            Tries to parse specified string to DateTime, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToGuid(System.String,System.Guid)">
            <summary>
            Tries to parse specified string to Guid, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Is(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Lock(System.Action)">
            <summary>
            Performs a lock operation (using a private object) on the specified action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Fx.Lock``1(System.Func{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action and return the operation return value;
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Lock``1(``0,System.Action{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action and return @this;
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#Else(System.Action)">
            <summary>
            Performs the else part of the if statement its chained to.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#ElseIf(System.Func{System.Boolean})">
            <summary>
            Prepares for the extra ElseIf condition, this requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#ElseIf(System.Boolean)">
            <summary>
            Prepares for the extra ElseIf condition, this requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Then(System.Action)">
            <summary>
            Performs the action for the previous conditional control statment (If, ElseIf).
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#And(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#And(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#AndNot(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#AndNot(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Or(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Or(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#OrNot(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#OrNot(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xor(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using XOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xor(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using XOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xnor(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using XNOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xnor(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using XNOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#Do(System.Action)">
            <summary>
            Performs the specified action after evaluating the previous looping statement.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#While(System.Func{System.Boolean})">
            <summary>
            Performs the while statement using the specified condition statement after evaluating the previous Do statement.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#LateBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#LateContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoop#Do(System.Action)">
            <summary>
            Performs the Do statement after evaluating the previous looping statement.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#LateBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#LateContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoop#While(System.Func{System.Boolean})">
            <summary>
            Performs the while statement using the specifed condition after it has evaluated the previous chained Do statement.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Swallow">
            <summary>
            Performs the previously chained Try action and swallow any exception that might occur.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``1">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``2">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``3">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``4">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <typeparam name="Exception4"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch(System.Action{System.Exception})">
            <summary>
            Performs the previously chained Try action and catches any exception and performs the specified action for the catch.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch``1(System.Action{``0})">
            <summary>
            Performs the previously chained Try action and catches the specified exception(s) and performs the specified action for each catch.
            </summary>
            <typeparam name="Exception1"></typeparam>
            <param name="action1"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch``2(System.Action{``0},System.Action{``1})">
            <summary>
            Performs the previously chained Try action and catches the specified exception(s) and performs the specified action for each catch.
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <param name="action1"></param>
            <param name="action2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchBuilder#Case``1(``0)">
            <summary>
            Prepares a Case statement for the previously chained Switch statement, this requires the usage of Execute after it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeBuilder#Case``1">
            <summary>
            Prepares a Case statement for the previously chained Switch statement, this requires the usage of Execute after it.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchCaseBuilder#Execute(System.Action)">
            <summary>
            Prepares for the execution of the specified action in case its chained Case has been evaluated.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeCaseBuilder#Execute(System.Action)">
            <summary>
            Prepares for the execution of the specified action in case its chained Case has been evaluated.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchBuilder#Default(System.Action)">
            <summary>
            Performs the previously chained switch statement along with its chained cases.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeBuilder#Default(System.Action)">
            <summary>
            Performs the previously chained switch statement along with its chained cases.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.TernaryOperator(System.Boolean,System.Action,System.Action)">
            <summary>
            Implementation of the Ternary operator
            </summary>
            <param name="condition"></param>
            <param name="trueAction"></param>
            <param name="falseAction"></param>
        </member>
        <member name="M:Fluentx.Fx.RandomBoolean">
            <summary>
            Returns a random value of boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.FlipCoin">
            <summary>
            Returns a random value of boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.RandomString(System.Int32)">
            <summary>
            Returns a random string with a specified length.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.NewSequentialGuid(Fluentx.SequentialGuidType)">
            <summary>
            Generates a time based sequential guid based on COMB algorithm, original implementation from Jeremy Todd on codeproject.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Fx.CaseInfo">
            <summary>
            Private class to hold information about switch case statement.
            </summary>
        </member>
        <member name="T:Fluentx.Guard">
            <summary>
            Behavioural presenation of throwing expected exceptions
            </summary>
            
        </member>
        <member name="M:Fluentx.Guard.Against(System.Boolean,System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the conditionToThroughException
            is true, with the specificied message.
            </summary>
            <param name="conditionToThroughException">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            Guard.Against(string.IsNullOrEmpty(name), "Name must have a value");
            </code>
            </example>
        </member>
        <member name="M:Fluentx.Guard.Against(System.Func{System.Boolean},System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the conditionActionToThroughException
            is true, with the specificied message.
            </summary>
            <param name="conditionActionToThroughException"></param>
            <param name="message"></param>
        </member>
        <member name="M:Fluentx.Guard.Against``1(System.Boolean,System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the conditionToThroughException is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="conditionToThroughException">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            <![CDATA[
            Guard.Against<ArgumentException>(string.IsNullOrEmpty(name), "Name must have a value");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Fluentx.Guard.Against``1(System.Func{System.Boolean},System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the conditionActionToThroughException is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="conditionActionToThroughException"></param>
            <param name="message"></param>
        </member>
        <member name="T:Fluentx.IFluentInterface">
            <summary>
            Represnt the core of a fluent interface in fluentx
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.GetType">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.GetType"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.GetHashCode">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.GetHashCode"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.ToString">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.ToString"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.Equals(System.Object)">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.Equals(System.Object)"/> method from IntelliSense.
            </summary>
        </member>
        <member name="T:Fluentx.IAction">
            <summary>
            Represnt an Action for fluentx
            </summary>
        </member>
        <member name="T:Fluentx.IConditionBuilder">
            <summary>
            Any condition builder.
            </summary>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Then(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.And(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.And(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.AndNot(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.AndNot(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Or(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Or(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.OrNot(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.OrNot(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xor(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xnor(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xnor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IConditionalAction">
            <summary>
            Any condition action.
            </summary>
        </member>
        <member name="M:Fluentx.IConditionalAction.Else(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionalAction.ElseIf(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionalAction.ElseIf(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ILoopAction">
            <summary>
            Any loop action.
            </summary>
        </member>
        <member name="T:Fluentx.IEarlyLoopBuilder">
            <summary>
            Any early loop builder (e.g while)
            </summary>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.Do(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.LateBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.LateContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IEarlyLoop">
            <summary>
            Any early loop (e.g while).
            </summary>
        </member>
        <member name="M:Fluentx.IEarlyLoop.Do(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ILateLoop">
            <summary>
            Any late loop (e.g Do-While).
            </summary>
        </member>
        <member name="M:Fluentx.ILateLoop.While(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ILateLoopBuilder">
            <summary>
            Any late loop builder (e.g Do-While)
            </summary>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.While(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.LateBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.LateContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ITriableAction">
            <summary>
            Any action might or might not complete successfully.
            </summary>
        </member>
        <member name="M:Fluentx.ITriableAction.Swallow">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``1">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``2">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``3">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``4">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <typeparam name="Exception4"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch(System.Action{System.Exception})">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch``1(System.Action{``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch``2(System.Action{``0},System.Action{``1})">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="action1"></param>
            <param name="action2"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchBuilder">
            <summary>
            Switch statement builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchBuilder.Case``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISwitchBuilder.Default(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchTypeBuilder">
            <summary>
            Switch statement for Types builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchTypeBuilder.Case``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISwitchTypeBuilder.Default(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchCaseBuilder">
            <summary>
            Switch case statement builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchCaseBuilder.Execute(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchTypeCaseBuilder">
            <summary>
            Switch case statement for types builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchTypeCaseBuilder.Execute(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.LifeCycle">
            <summary>
            Represents the life cycle of a registered container entry
            </summary>
        </member>
        <member name="F:Fluentx.LifeCycle.Transient">
            <summary>
            IoC container resolves by creating a new instance on every resolve
            </summary>
        </member>
        <member name="F:Fluentx.LifeCycle.Singleton">
            <summary>
            IoC container resolves by creating a new instance for the first time then reuse that value for the afterwards calls
            </summary>
        </member>
        <member name="T:Fluentx.AutoRegisterMode">
            <summary>
            Used with auto registration of classes
            </summary>
        </member>
        <member name="F:Fluentx.AutoRegisterMode.Flexible">
            <summary>
            If resolve type interface not found then the concreteType is used as a resolve type
            </summary>
        </member>
        <member name="F:Fluentx.AutoRegisterMode.Strict">
            <summary>
            If resolve type interface not found then no registration happens
            </summary>
        </member>
        <member name="T:Fluentx.IoC">
            <summary>
            Its a simple Inversion of Control resolver that help in registering resolve types against 
            concrete types with support for simple DI (Dependency Injection)
            </summary>
        </member>
        <member name="T:Fluentx.IoC.IoCContainer">
            <summary>
            Based on Jimmy Bogard's implementation for simple IoC container
            </summary>
        </member>
        <member name="M:Fluentx.IoC.IoCContainer.Register(System.Type,System.Type)">
            <summary>
            Registers the specified resolve and concerete types in the container, null values are ignored and not registered.
            </summary>
            <param name="resolveType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:Fluentx.IoC.IoCContainer.Register(System.Type,System.Type,Fluentx.LifeCycle)">
            <summary>
            Registers the specified resolve and concerete types in the container, null values are ignored and not registered.
            </summary>
            <param name="resolveType"></param>
            <param name="concreteType"></param>
            <param name="lifeCycle"></param>
        </member>
        <member name="M:Fluentx.IoC.IoCContainer.Resolve``1">
            <summary>
            Returns a concrete instance of the specified resolve type
            </summary>
            <typeparam name="TResolveType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IoC.IoCContainer.Resolve(System.Type)">
            <summary>
            Returns a concrete instance of the specified resolve type
            </summary>
            <param name="resolveType"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IoC.Register``2">
            <summary>
            Registers the specified resolveType and concrete type in the container
            </summary>
            <typeparam name="TResolveType"></typeparam>
            <typeparam name="TConcretType"></typeparam>
        </member>
        <member name="M:Fluentx.IoC.Register``2(Fluentx.LifeCycle)">
            <summary>
            Registers the specified resolveType and concrete type in the container
            </summary>
            <typeparam name="TResolveType"></typeparam>
            <typeparam name="TConcretType"></typeparam>
            <param name="lifeCycle"></param>
        </member>
        <member name="M:Fluentx.IoC.Resolve``1">
            <summary>
            Tries to resolve the specified resolveType by retrieving instance of the 
            registered concrete type in the container.
            </summary>
            <typeparam name="TResolveType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IoC.AutoRegisterByInterfaces(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Tries to register interfaces only from the collection of types provided by 
            having the interface as ResolveType and interface name without "I" as concreteType.
            e.g ISomething => Something
            </summary>
            <param name="types">Only interfaces will be looked up for auto registeration</param>
        </member>
        <member name="M:Fluentx.IoC.AutoRegisterByClasses(System.Collections.Generic.IEnumerable{System.Type},Fluentx.AutoRegisterMode)">
            <summary>
            Tries to register classes only from the collection of types provided by having
            the class as a ConcreteType and the ConcreteType prefixed with "I" as the 
            Resolve Type, if no interface found the concreteType it self is used only in case AutoRegistrationMode is set to Flexable.
            </summary>
            <param name="types">Only classes will be lookup for auto registration</param>
            <param name="autoRegisterMode">Either Strict or </param>
        </member>
        <member name="M:Fluentx.IoC.AutoRegisterByClassesAsIs(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Tries to register classes only from the collection of types provided by 
            having the resolve type and concrete type the same type provided
            </summary>
            <param name="typesToAutoRegister"></param>
        </member>
        <member name="T:Fluentx.IMapper">
            <summary>
            Main Interface for fluentx object to object mapper
            </summary>
        </member>
        <member name="P:Fluentx.IMapper.SourceType">
            <summary>
            Mapper Source Type 
            </summary>
        </member>
        <member name="P:Fluentx.IMapper.DestinationType">
            <summary>
            Mapper Destination Type
            </summary>
        </member>
        <member name="T:Fluentx.IMapper`2">
            <summary>
            When overriden it provides functionalities to map from object to object (source to destination) using convention based mapping and a set of custom user rules mapping.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TDestination"></typeparam>
        </member>
        <member name="M:Fluentx.IMapper`2.Conditional(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally maps the specified destination member from the source instance if found according to conditionalAction value.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.For``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0})">
            <summary>
            Maps the specified destination member using the specified resolver.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.ForIf``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0},System.Func{`0,System.Boolean})">
            <summary>
            Maps the specified destination member using the specified resolver if the conditionalAction evaluated to true
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <param name="conditionalAction">The action which its value will determine if to map using the resolver specified or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Ignores mapping of the specified destination member
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.IgnoreIf(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally ignores the specified destination member from mapping
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.UseMapper``2">
            <summary>
            Creates and adds a new mapper to list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.UseMappers(Fluentx.IMapper[])">
            <summary>
            Creates and adds a new mapper to list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <param name="subMappers"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Resolve(System.Action{`0,`1})">
            <summary>
            Use this method to do custom actions through the mapper, handy to tigh custom resolvings with the mapper. Resolvers are the last things to be executed throught the mapper.
            </summary>
            <param name="resolver">Custom action to do whatever on the mapper</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Map(`0)">
            <summary>
            Executes mapping and returns the destination instance mapped using the mapping rules specified in the mapper instance.
            </summary>
            <param name="source">The source instance to map from</param>
            <returns>The destination instance which will be returned from the process of mapping</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Map(`0,`1)">
            <summary>
            Executes mapping between source and destination instances
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Mapper`2">
            <summary>
            This class is used to do object to object mapping (source to destination) using convention based mapping and custom rules mapping
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TDestination"></typeparam>
        </member>
        <member name="M:Fluentx.Mapper`2.#ctor">
            <summary>
            Create an empty mapper
            </summary>
        </member>
        <member name="M:Fluentx.Mapper`2.#ctor(Fluentx.IMapper[])">
            <summary>
            Creates a mapper using the supplied mappers as inner mappers
            </summary>
            <param name="mappers"></param>
        </member>
        <member name="M:Fluentx.Mapper`2.Create(System.Type,System.Type)">
            <summary>
            Creates a mapper using the specified source type and destination type
            </summary>
            <param name="sourceType"></param>
            <param name="destType"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Create``2">
            <summary>
            Creates a mapper with the specified types.
            </summary>
            <typeparam name="TSrc"></typeparam>
            <typeparam name="TDest"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Fluentx.Mapper`2.SourceType">
            <summary>
            Mapper source type
            </summary>
        </member>
        <member name="P:Fluentx.Mapper`2.DestinationType">
            <summary>
            Mapper destination type
            </summary>
        </member>
        <member name="M:Fluentx.Mapper`2.MapInstanceToInstance(`0,`1)">
            <summary>
            Executes mapping
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
        </member>
        <member name="M:Fluentx.Mapper`2.Conditional(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally maps the specified destination member from the source instance if found according to conditionalAction value.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.For``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0})">
            <summary>
            Maps the specified destination member using the specified resolver.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.ForIf``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0},System.Func{`0,System.Boolean})">
            <summary>
            Maps the specified destination member using the specified resolver if the conditionalAction evaluated to true
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <param name="conditionalAction">The action which its value will determine if to map using the resolver specified or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Ignores mapping of the specified destination member
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.IgnoreIf(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally ignores the specified destination member from mapping
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.UseMapper``2">
            <summary>
            Creates and adds a new mapper to list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.UseMappers(Fluentx.IMapper[])">
            <summary>
            Adds the specified mappers to the current mapper.
            </summary>
            <param name="subMappers"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Resolve(System.Action{`0,`1})">
            <summary>
            Use this method to do custom actions through the mapper, handy to tigh custom resolvings with the mapper. Resolvers are the last things to be executed throught the mapper.
            </summary>
            <param name="resolver">Custom action to do whatever on the mapper</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(`0)">
            <summary>
            Executes mapping and returns the destination instance mapped using the mapping rules specified in the mapper instance.
            </summary>
            <param name="source">The source instance to map from</param>
            <returns>The destination instance which will be returned from the process of mapping</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(`0,`1)">
            <summary>
            Executes mapping between source and destination instances
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Executes the mapping from source and returns a new destination.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IList{`1})">
            <summary>
            Executes the mapping from source and suppplies it to the specified destination.
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.MultitionaryBase`2">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TKuple"></typeparam>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.MultitionaryBase`2.Current">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.Add(`1)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.Remove(`0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.MultitionaryBase`2.ContainsKey(`0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Fluentx.MultitionaryBase`2.Item(`0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Fluentx.MultitionaryBase`2.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluentx.Multitionary`2">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`3">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`4">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`5">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`6">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`7">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`8">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
        </member>
        <member name="T:Fluentx.IKuple">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
        </member>
        <member name="T:Fluentx.IKuple`1">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:Fluentx.IKuple`1.Key">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluentx.Kuple`8">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`8.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value3">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value4">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value5">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value6">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`8.Value7">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
            <param name="value5"></param>
            <param name="value6"></param>
            <param name="value7"></param>
        </member>
        <member name="T:Fluentx.Kuple`7">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`7.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value3">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value4">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value5">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`7.Value6">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
            <param name="value5"></param>
            <param name="value6"></param>
        </member>
        <member name="T:Fluentx.Kuple`6">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`6.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`6.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`6.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`6.Value3">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`6.Value4">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`6.Value5">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
            <param name="value5"></param>
        </member>
        <member name="T:Fluentx.Kuple`5">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`5.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`5.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`5.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`5.Value3">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`5.Value4">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
        </member>
        <member name="T:Fluentx.Kuple`4">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`4.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`4.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`4.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`4.Value3">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
        </member>
        <member name="T:Fluentx.Kuple`3">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`3.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`3.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`3.Value2">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`3.#ctor(`0,`1,`2)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="T:Fluentx.Kuple`2">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
        </member>
        <member name="P:Fluentx.Kuple`2.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluentx.Kuple`2.Value1">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.Kuple`2.#ctor(`0,`1)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value1"></param>
        </member>
        <member name="T:Fluentx.PagedData`1">
            <summary>
            A simple container class for paged data.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.PagedData`1.Data">
            <summary>
            The paged data returned
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.TotalCount">
            <summary>
            Total count of data without paging
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.PageIndex">
            <summary>
            Page Index
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.PageSize">
            <summary>
            Page Size
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.SortBy">
            <summary>
            Sorty by
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.SortDirection">
            <summary>
            Sort direction
            </summary>
        </member>
        <member name="T:Fluentx.Period">
            <summary>
            A class represents a time period between to date item instances.
            </summary>
        </member>
        <member name="P:Fluentx.Period.Start">
            <summary>
            Period start datetime
            </summary>
        </member>
        <member name="P:Fluentx.Period.End">
            <summary>
            Period end datetime
            </summary>
        </member>
        <member name="P:Fluentx.Period.Length">
            <summary>
            Period length as a timespan
            </summary>
        </member>
        <member name="M:Fluentx.Period.#ctor(System.DateTime,System.DateTime)">
            <summary>
            Creates a period with the specified start and end dates
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Fluentx.Period.IsOverlap(Fluentx.Period,System.Boolean)">
            <summary>
            Returns if the specified period overlaps with the current one, a boolean value indicates wether edges should be calculated in the overlap or not, by default its false
            </summary>
            <param name="otherPeriod"></param>
            <param name="edgesOverlap"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Period.IsWrap(System.DateTime,System.Boolean)">
            <summary>
            Returns a boolean wether the specified date is within the current period.(edges are not calculated within)
            </summary>
            <param name="date"></param>
            /// <param name="includeEdges"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.PredicateBuilder">
            <summary>
            Helps building prediates to provide And/AndNot/Or/OrNot/Not true/false for linq expressions
            </summary>
        </member>
        <member name="M:Fluentx.PredicateBuilder.True``1">
            <summary>
            Presents a true predicate
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.False``1">
            <summary>
            Presents false predicates
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Create``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Creates a predicate using the specified expression
            </summary>
            <typeparam name="T"></typeparam>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Ors a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            And a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Xor``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            XOring a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Not``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Negating a predicate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.AndNot``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Anding Not with another predicate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.OrNot``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Oring Not with another predicate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.SequentialGuidType">
            <summary>
            An enum for possible values to generate a sequential guid.
            </summary>
        </member>
        <member name="F:Fluentx.SequentialGuidType.SequentialAsString">
            <summary>
            Useful for MySQL and Postgre
            </summary>
        </member>
        <member name="F:Fluentx.SequentialGuidType.SequentialAsBinary">
            <summary>
            Useful for Oracle database
            </summary>
        </member>
        <member name="F:Fluentx.SequentialGuidType.SequentialAtEnd">
            <summary>
            Useful for SQL Server Based Guids as it has its own way of sorting the Guids
            </summary>
        </member>
        <member name="T:Fluentx.ISpecification`1">
            <summary>
            Represents the core of the specificaiton pattern
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.ISpecification`1.Messages">
            <summary>
            List of validation messages when it failed
            </summary>
        </member>
        <member name="M:Fluentx.ISpecification`1.Validate(`0)">
            <summary>
            When overriden in a derived class does the validation on the specification (Rule(s)) and return if it succeeds
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.ValidateAndContinue(`0)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.ValidateWithMessages(`0)">
            <summary>
            When overriden in a derived class does the validaiton on the specification (Rule(s)) and return list of validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.And(Fluentx.ISpecification{`0})">
            <summary>
            And a specification with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.Or(Fluentx.ISpecification{`0})">
            <summary>
            Or a specificaiton with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.Xor(Fluentx.ISpecification{`0})">
            <summary>
            Xor a specification with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.CompositeSpecification`1">
            <summary>
            Base abstract class for custom specifications 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.CompositeSpecification`1.Messages">
            <summary>
            Message returned for the specificaiton validation
            </summary>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Validate(`0)">
            <summary>
            Executes and Validates the specificaiton
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.ValidateAndContinue(`0)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specificaiton and return validation messages.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.And(Fluentx.ISpecification{`0})">
            <summary>
            Current specification AND specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Or(Fluentx.ISpecification{`0})">
            <summary>
            Current specification OR specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Xor(Fluentx.ISpecification{`0})">
            <summary>
            Current specification XOR specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.AndSpecification`1">
            <summary>
            Represents the And Specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.AndSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.AndSpecification`1.Validate(`0)">
            <summary>
            Executes and validates the specificaiton, this will NOT continue to the next specification if the validation fails
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.AndSpecification`1.ValidateAndContinue(`0)">
            <summary>
            Executes and validates the specificaiton, this will NOT continue to the next specification if the validation fails
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.AndSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.AndSpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            Executes and validate hte specification returning validation messages, this will return all failed validations.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.OrSpecification`1">
            <summary>
            Represents Or specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.OrSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.OrSpecification`1.Validate(`0)">
            <summary>
            Executes and validates the specificadtion returning the boolean result, in case of failed validation it will stop on the first failed validation without executing the remaining ones in the chain of validations.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.OrSpecification`1.ValidateAndContinue(`0)">
            <summary>
            Executes and validates the specificaiton, this will NOT continue to the next specification if the validation fails
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.OrSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.OrSpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            Executes and validates the specification and returns the messages and will continue even if the validation failed on the first one, all failed validation messages will return.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.XorSpecification`1">
            <summary>
            Represnts XOR specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.XorSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.XorSpecification`1.Validate(`0)">
            <summary>
            Executes and validates the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.XorSpecification`1.ValidateAndContinue(`0)">
            <summary>
            Executes and validates the specification (for Xor its no difference with Validate Method)
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.XorSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation meessages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.XorSpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            Executes and validates the specification and return validation meessages (for Xor no difference from Validate method)
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ExpressionSpecification`1">
            <summary>
            Represents an expression based specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="expression"></param>
            <param name="messages"></param>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.Validate(`0)">
            <summary>
            Validate the specification and return true or false
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.ValidateAndContinue(`0)">
            <summary>
            Will validate the specification and continue to the next node in rules chain.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.ValidateWithMessages(`0)">
            <summary>
            validates the specificaiton and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.ValidateWithMessagesAndContinue(`0)">
            <summary>
            Executes and validates the specification and returns all messages, it will not stop on the first failed validation.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.TypeNotRegisteredException">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluentx.TypeNotRegisteredException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Fluentx.UISearch`1">
            <summary>
            A simple container class to transfer ui search related data.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.UISearch`1.PageIndex">
            <summary>
            Page Index
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.PageSize">
            <summary>
            Page Size
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.SortBy">
            <summary>
            Sort By
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.SortDirection">
            <summary>
            Sort Direction
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.Criteria">
            <summary>
            The criteria used for filter
            </summary>
        </member>
    </members>
</doc>
